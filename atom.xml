<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Guest&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://guestblog.xyz/"/>
  <updated>2020-03-23T10:14:07.829Z</updated>
  <id>https://guestblog.xyz/</id>
  
  <author>
    <name>Guest</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何编译操作系统内核，并新增系统调用💡</title>
    <link href="https://guestblog.xyz/2020/03/23/OSC-Experiment/"/>
    <id>https://guestblog.xyz/2020/03/23/OSC-Experiment/</id>
    <published>2020-03-23T10:12:17.000Z</published>
    <updated>2020-03-23T10:14:07.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>已经获得了linux内核源代码。通过修改源代码，创建一个新的编号为320的系统调用，具体功能由自己指定。接着生成内核配置文件，并编译安装内核。最终使得开机时能够选择启动自己编译的内核，并成功调用新增的系统调用。</p><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过编写内核代码的方式，加深自己对操作系统内核的理解，使其概念变得不那么抽象。同时感受内核中系统调用的运作方式。</p><h2 id="设计思路以及流程图"><a href="#设计思路以及流程图" class="headerlink" title="设计思路以及流程图"></a>设计思路以及流程图</h2><h3 id="新增系统调用"><a href="#新增系统调用" class="headerlink" title="新增系统调用"></a>新增系统调用</h3><p>打开虚拟机，在桌面发现linux内核压缩文件，首先将其解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Desktop</span><br><span class="line">$ tar zxvf linux-2.6.21.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> linux-2.6.21</span><br></pre></td></tr></table></figure><img src="/2020/03/23/OSC-Experiment/1.png" class=""><p>接着可以看到解压好的内核。</p><p>我们开始尝试新增一个320号系统调用。</p><p>打开终端，cd到内核目录，使用vi编辑arch/i386/kernel/syscall_table.S，在尾部加上psta系统调用。</p><img src="/2020/03/23/OSC-Experiment/2.png" class=""><p>然后我们在include/linux目录下添加psta.h头文件：</p><img src="/2020/03/23/OSC-Experiment/3.png" class=""><p>其中nice是标志符，当其为0时代表没有调用，当成功调用该syscall时将其置为1。</p><p>接着，修改include/linux目录下的Kbuild文件，将psta.h添加进去：</p><img src="/2020/03/23/OSC-Experiment/4.png" class=""><p>在kernel目录下新建文件psta.c，在该文件中实现sys_psta函数：</p><p>这是我自己写的psta.c，其内容将在后文分析。</p><img src="/2020/03/23/OSC-Experiment/5.png" class=""><p>修改文件kernel/Makefile，使得psta.c在编译时可见：</p><img src="/2020/03/23/OSC-Experiment/14.png" class=""><p>在include/asm-i386/unistd.h里加上系统调用号的宏定义：</p><img src="/2020/03/23/OSC-Experiment/6.png" class=""><p>修改include/linux/syscalls.h，加上函数sys_psta的声明。</p><p>声明pinfo结构体：</p><img src="/2020/03/23/OSC-Experiment/7.png" class=""><p>添加psta.h头文件：</p><img src="/2020/03/23/OSC-Experiment/8.png" class=""><p>末尾添加函数声明：</p><img src="/2020/03/23/OSC-Experiment/9.png" class=""><h3 id="重新编译内核"><a href="#重新编译内核" class="headerlink" title="重新编译内核"></a>重新编译内核</h3><p>生成内核配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make mrproper</span><br><span class="line">$ cp /boot/config-`uname -r` ./config</span><br></pre></td></tr></table></figure><p>make mrproper保证内核树是干净的，这会删除.config文件，然后通过第二条命令将当前运行的内核config文件复制到自己编写的内核目录下。其中``符号代表bash执行返回结果，也就是说实际上返回的版本号拼接上config-就是config文件名。</p><blockquote><p>Linux采用了双树系统。一个树是稳定树（stable tree），另一个树是非稳定树（unstable tree）或者开发树（development tree）。一些新特性、实验性改进等都将首先在开发树中进行。如果在开发树中所做的改进也可以应用于稳定树，那么在开发树中经过测试以后，在稳定树中将进行相同的改进。一旦开发树经过了足够的发展，开发树就会成为新的稳定树。</p><p>参考链接：<a href="https://blog.csdn.net/zhenguo26/article/details/79641322" target="_blank" rel="noopener">https://blog.csdn.net/zhenguo26/article/details/79641322</a></p></blockquote><p>接着更新config文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make oldconfig</span><br></pre></td></tr></table></figure><p>更改Makefile文件，定义自己的内核版本号，我将其设置为-seu。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXTRAVERSION &#x3D; -seu</span><br></pre></td></tr></table></figure><p>最后编译安装内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make all</span><br><span class="line">$ su</span><br><span class="line">$ make modules_install</span><br><span class="line">$ make install</span><br><span class="line">$ make headers_install</span><br></pre></td></tr></table></figure><p>重启系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ reboot</span><br></pre></td></tr></table></figure><p>可以发现启动页面以及有了我们编译的新内核。</p><img src="/2020/03/23/OSC-Experiment/10.png" class=""><p>打开终端，执行<code>uname -r</code>命令，可以验证我们的内核版本确实已经切换。</p><img src="/2020/03/23/OSC-Experiment/11.png" class=""><p>这时候开始验证我们的代码是否起能成功调用我们写的320号system call。</p><h2 id="源程序以及注释"><a href="#源程序以及注释" class="headerlink" title="源程序以及注释"></a>源程序以及注释</h2><p>以下是psta.c的源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/linkage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/psta.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_psta</span><span class="params">(struct pinfo *buf)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//nice=1 represents system call is successfully invoked</span></span><br><span class="line">    buf-&gt;nice = <span class="number">1</span>;</span><br><span class="line">printk(<span class="string">"This system call is successfully running!\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//print the pid into system log</span></span><br><span class="line">printk(<span class="string">"The pid of the process that invoked this system call is %d\n"</span>,buf-&gt;pid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//print the uid into system log</span></span><br><span class="line">printk(<span class="string">"The uid of the user that invoked this system call is %d\n"</span>,buf-&gt;uid);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在320号system call中，将传入的pinfo结构体的nice变量赋值为1，代表成功调用了。并在内核日志中打印调用该system call进程的pid以及用户的uid。下面继续来看测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/psta.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The pid of current process is %d\n"</span>,getpid());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The current uid is %d\n"</span>,getuid());</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinfo</span> <span class="title">info</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//initialize variable nice with 0</span></span><br><span class="line">info.nice = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//obtain the pid and uid</span></span><br><span class="line">info.pid = getpid();</span><br><span class="line">info.uid = getuid();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if the system call is successfully invoked, the return value of ret will be 0</span></span><br><span class="line"><span class="keyword">int</span> ret = syscall(<span class="number">320</span>,&amp;info);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0 represents this system call is successfully invoked,ret:%d\n"</span>,ret);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The system call change the value of nice into:%d\n"</span>,info.nice);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，我们的预期结果是：</p><ul><li>nice变量的值通过系统调用变成了1</li><li>ret变量返回0，代表成功调用320号system call，否则返回-1</li><li>内核日志中打印出的pid与uid与程序输出一致</li></ul><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><p>下面是运行结果：</p><img src="/2020/03/23/OSC-Experiment/12.png" class=""><p>可以看出：</p><ul><li>当权限为用户时，当前uid是500，程序的进程号为3951</li><li>当权限为管理员时，当前uid是0，程序的进程号是3971</li><li>两次的nice值均改变为1</li><li>两次的ret值均返回0</li></ul><p>再来看内核日志：</p><img src="/2020/03/23/OSC-Experiment/13.png" class=""><p>内核日志与程序输出结果相符，实验成功。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>这次操作系统实验是我第一次在内核态编程，过程很繁琐复杂，但同时也受益匪浅。在实验的过程中，我遇到了很多的bug，以及各种奇怪的编译错误，甚至虚拟机无法启动得推倒重来。即便如此，最终还是通过百度谷歌各种方式一一解决了bug。下面是我的个人的一些体悟。</p><h3 id="关于内核"><a href="#关于内核" class="headerlink" title="关于内核"></a>关于内核</h3><p>我觉得内核是连接用户程序与硬件的一个桥梁，在用户态写代码时，我们只能调用内核给定好的system call进行操作。而各种system call的功能是相对安全的，用户不能直接对底层硬件进行操作，因此内核一个很重要的功能就是让用户的操作更加规范且安全，这是一个保护机制。</p><p>linux是开源的，我们可以在操作规范的前提下编写自己的内核，打开内核目录，可以看到各式各样的.h以及.c文件，这些都是最底层的系统api，因此编写的时候必须十分谨慎，稍有不慎就可能导致系统崩溃。</p><p>同时，编译内核也是一个繁琐的过程，每一次更改自己编写的系统调用，make all都需要等待相当长的时间，因为编译器需要对整一个内核进行重新编译、链接。</p><h3 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h3><p>在编写system call的过程中，我有许多想实现的功能没法实现，经过百度，我发现这是因为内核态和用户态的不同而导致的。</p><p>例如，在psta.c中，开始我希望能够获取当前进程的pid，并将其存放在pinfo的pid变量中。我尝试使用getpid()，但编译提示说找不到头文件。原来，linux下的C库在内核态下是无法使用的，这些C库包含的是已经封装好system call的函数，只能在用户态下使用。而内核态显然是更底层的，因此在内核态无法使用用户态的C库和各种函数。而如果想要在内核态中使用用户态的某些功能，就必须找到内核中对应的头文件和函数。在linux内核中有一个宏current，current-&gt;pid即指向当前的pid。为此我尝试了使用current，但是失败了，最后返回的结果是一个负数，但我始终没能找出原因。</p><p>再例如，在内核程序中我们没法通过include&lt;stdio.h&gt;来使用printf函数，取而代之的是printk，这个函数可以将消息打印在内核日志中。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>Linux内核是一个复杂而精细的东西，在使用修改的过程中必须要十分小心，但这也是Linux内核的魅力所在。有次在编译的过程中，由于没有重新生成内核配置文件就编译，出了很多莫名其妙的错误，到最后才发现。Linux的维护者在编写内核代码时想必也是十分小心的，我想，如果底层api中出现了漏洞，那么黑客就很可能会通过编写恶意的漏洞利用程序来进行攻击。因此，阅读内核代码，可以体会到Linux维护者是如何编写高效而安全的程序的。自己编写系统调用，在确保安全的前提下，可以提升系统中某些功能的运行效率，若想实现某一功能，只需调用我们自己编写的system call，而不用通过用户态函数。这样效率将极大提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;p&gt;已经获得了linux内核源代码。通过修改源代码，创建一个新的编号为320的系统调用，具体功能由自己指定。接着生成内核配置文件
      
    
    </summary>
    
    
      <category term="OS" scheme="https://guestblog.xyz/categories/OS/"/>
    
    
      <category term="OS" scheme="https://guestblog.xyz/tags/OS/"/>
    
      <category term="Linux" scheme="https://guestblog.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PHP中为什么fopen()函数能以路径为参数创建文件?🐘</title>
    <link href="https://guestblog.xyz/2020/03/21/phpvuln/"/>
    <id>https://guestblog.xyz/2020/03/21/phpvuln/</id>
    <published>2020-03-21T02:41:12.000Z</published>
    <updated>2020-03-23T10:14:40.880Z</updated>
    
    <content type="html"><![CDATA[<p>之所以写这一篇博客，是因为XCTF攻防世界的一道题目：ics-07。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>先来看看题目，我的疑惑也是在做题的时候产生的。</p><p>点进去是一个平台管理中心页面，试了下发现只有“项目管理”一栏是可以点的，点进去的页面如下：</p><img src="/2020/03/21/phpvuln/1.png" class=""><p>乍一看以为是sql注入，但是留意到下面的view-source按钮，点开来看，获得了源代码。</p><a id="more"></a><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;cetc7&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line">    session_start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($_GET[page])) &#123;</span><br><span class="line">      show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">      <span class="keyword">die</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[page]) &amp;&amp; $_GET[page] != <span class="string">'index.php'</span>) &#123;</span><br><span class="line">      <span class="keyword">include</span>(<span class="string">'flag.php'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      header(<span class="string">'Location: ?page=flag.php'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;form action=<span class="string">"#"</span> method=<span class="string">"get"</span>&gt;</span><br><span class="line">      page : &lt;input type=<span class="string">"text"</span> name=<span class="string">"page"</span> value=<span class="string">""</span>&gt;</span><br><span class="line">      id : &lt;input type=<span class="string">"text"</span> name=<span class="string">"id"</span> value=<span class="string">""</span>&gt;</span><br><span class="line">      &lt;input type=<span class="string">"submit"</span> name=<span class="string">"submit"</span> value=<span class="string">"submit"</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;a href=<span class="string">"index.phps"</span>&gt;view-source&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line">     <span class="keyword">if</span> ($_SESSION[<span class="string">'admin'</span>]) &#123;</span><br><span class="line">       $con = $_POST[<span class="string">'con'</span>];</span><br><span class="line">       $file = $_POST[<span class="string">'file'</span>];</span><br><span class="line">       $filename = <span class="string">"backup/"</span>.$file;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(preg_match(<span class="string">'/.+\.ph(p[3457]?|t|tml)$/i'</span>, $filename))&#123;</span><br><span class="line">          <span class="keyword">die</span>(<span class="string">"Bad file extension"</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            chdir(<span class="string">'uploaded'</span>);</span><br><span class="line">           $f = fopen($filename, <span class="string">'w'</span>);</span><br><span class="line">           fwrite($f, $con);</span><br><span class="line">           fclose($f);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[id]) &amp;&amp; floatval($_GET[id]) !== <span class="string">'1'</span> &amp;&amp; substr($_GET[id], <span class="number">-1</span>) === <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">include</span> <span class="string">'config.php'</span>;</span><br><span class="line">        $id = mysql_real_escape_string($_GET[id]);</span><br><span class="line">        $sql=<span class="string">"select * from cetc007.user where id='$id'"</span>;</span><br><span class="line">        $result = mysql_query($sql);</span><br><span class="line">        $result = mysql_fetch_object($result);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $result = <span class="keyword">False</span>;</span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!$result)<span class="keyword">die</span>(<span class="string">"&lt;br &gt;something wae wrong ! &lt;br&gt;"</span>);</span><br><span class="line">      <span class="keyword">if</span>($result)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"id: "</span>.$result-&gt;id.<span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"name:"</span>.$result-&gt;user.<span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line">        $_SESSION[<span class="string">'admin'</span>] = <span class="keyword">True</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>通过阅读源码我们得知首先需要让SESSION的变量admin的值为真。</p><p>首先是一行php比较运算符：</p><p><code>if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== &#39;1&#39; &amp;&amp; substr($_GET[id], -1) === &#39;9&#39;)</code></p><p>我们需要构造一个GET传参的id，使其浮点类型与&#39;1&#39;不全等，且该变量最后一位是&#39;9&#39;，同时服务器用该sql查询语句进行查询需要返回结果。这里我们可以构造id=1-9。floatval()函数的功能是将一个变量转化为浮点类型，当转换过程中遇到特殊字符便不再继续转换，所以1-9将会被转换为1，而浮点类型和字符类型必然不全等，所以第二个很容易绕过。</p><img src="/2020/03/21/phpvuln/2.png" class=""><p>这时候问题来到了第二段代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     <span class="keyword">if</span> ($_SESSION[<span class="string">'admin'</span>]) &#123;</span><br><span class="line">       $con = $_POST[<span class="string">'con'</span>];</span><br><span class="line">       $file = $_POST[<span class="string">'file'</span>];</span><br><span class="line">       $filename = <span class="string">"backup/"</span>.$file;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(preg_match(<span class="string">'/.+\.ph(p[3457]?|t|tml)$/i'</span>, $filename))&#123;</span><br><span class="line">          <span class="keyword">die</span>(<span class="string">"Bad file extension"</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           chdir(<span class="string">'uploaded'</span>);</span><br><span class="line">           $f = fopen($filename, <span class="string">'w'</span>);</span><br><span class="line">           fwrite($f, $con);</span><br><span class="line">           fclose($f);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>chdir是切换目录，我们可以发现目录切换到了uploaded，很明显到这里就是文件上传了。fopen是打开一个文件，如果没有就创建一个新文件。$con是我们要写入文件的内容，这里选择写入一个一句话木马。但是注意到前面有一个正则的过滤语句：</p><p><code>if(preg_match(&#39;/.+\.ph(p[3457]?|t|tml)$/i&#39;, $filename))</code></p><p>这句话的意思就是过滤掉所有以php或其变体为后缀的文件。linux下有一个mime.types文件，我们可以在里面找到所有的php后缀：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/mime.types | grep php</span><br><span class="line"><span class="comment">#application/x-httpd-php            phtml pht php</span></span><br><span class="line"><span class="comment">#application/x-httpd-php-source            phps</span></span><br><span class="line"><span class="comment">#application/x-httpd-php3            php3</span></span><br><span class="line"><span class="comment">#application/x-httpd-php3-preprocessed        php3p</span></span><br><span class="line"><span class="comment">#application/x-httpd-php4            php4</span></span><br><span class="line"><span class="comment">#application/x-httpd-php5            php5</span></span><br></pre></td></tr></table></figure><p>这里可以看出，所有的php文件后缀都被过滤了，而phps和php3p是源代码文件，无法作为脚本被执行。在这个地方，我在网上搜了很多个师傅的博客，他们的答案都无法让我满意，我总觉得很多的解释都是错误的。</p><h2 id="关键的地方"><a href="#关键的地方" class="headerlink" title="关键的地方"></a>关键的地方</h2><p>事实上，file只要为123.php/.就可以成功绕过正则，但是问题是，为什么php可以把一个路径当成文件来创建呢？这里我百思不得其解。网上的答案也是五花八门：</p><blockquote><p>利用了一个Linux的目录结构特性， 创建了一个目录为1.php , 在 1.php 下创建了一个子目录为 2.php . Linux下每创建一个新目录 , 都会在其中自动创建两个隐藏文件。其中 .. 代表当前目录的父目录 ,  . 代表当前目录 , 所以这里访问 ./1.php/2.php/.. 代表访问 2.php 的父目录 , 也就是访问 1.php</p></blockquote><p>在明白原因之后我觉得很多师傅的解答简直是误人子弟。这跟linux又有什么关系呢？按照这个说法，123.php的类型很显然是目录，即便是通过..创建了123.php，但是目录类型的文件也是不能被当作php脚本来执行的。我觉得，在这个地方，网上百分之90以上的witeup都是知其然而不知其所以然。</p><p>我把这个题目放到了群里去问SUS的师傅们，最终弄明白了为什么，这里要感谢马师傅，他一下就觉得是php的问题，推给我的文章让我真正弄明白了这个问题。同时也感谢写文章的Dlive师傅，他的钻研精神让我很敬佩。</p><p>很幸运，Dlive师傅遇到的也是同一道题目，他通过调试php源码，得出了问题是出在php的fopen()方法上。这里我对他的结果做一个解释：</p><p>事实上，在参数传入fopen()方法中被调用之前，fopen()首先会调用一个expand_filepath函数，也就是在这个函数之后，原本的&#39;123.php/.&#39;路径转换成了&#39;123.php&#39;，使得php得以正常创建文件。</p><p>在expand_filepath函数中，会调用一个tsrm_realpath_r对路径进行递归标准化，避免路径中存在<code>//</code>以及<code>/./</code>等问题，之后真正送入fopen方法创建文件的路径实际上就是&#39;123.php&#39;。看到这里我恍然大悟。也就是说tsrm_realpath_r这个函数实际上会将任何路径中的<code>../</code>以及<code>/.</code>之类的操作符给消去，得到真正的路径，也就是路径规范化。123.php其实在创建之初就不是一个目录的类型，而是php脚本类型。</p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>在做这道题目的过程中，我翻遍了许多人的博客，都没有得到满意的答案，但是并没放弃，最后终于明白了为什么。我最大的感受就是，并不一定大家都认可的观点就一定是正确的，对待每一个似是而非的问题都不能轻易地下结论，接受别人的观点，而是要刨根问底，真正弄明白为什么。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之所以写这一篇博客，是因为XCTF攻防世界的一道题目：ics-07。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;先来看看题目，我的疑惑也是在做题的时候产生的。&lt;/p&gt;
&lt;p&gt;点进去是一个平台管理中心页面，试了下发现只有“项目管理”一栏是可以点的，点进去的页面如下：&lt;/p&gt;
&lt;img src=&quot;/2020/03/21/phpvuln/1.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;乍一看以为是sql注入，但是留意到下面的view-source按钮，点开来看，获得了源代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="https://guestblog.xyz/categories/php/"/>
    
    
      <category term="php" scheme="https://guestblog.xyz/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>实现vscode+Xdebug调试php🐘</title>
    <link href="https://guestblog.xyz/2020/02/25/Xdebug-php/"/>
    <id>https://guestblog.xyz/2020/02/25/Xdebug-php/</id>
    <published>2020-02-25T06:47:43.000Z</published>
    <updated>2020-03-23T10:08:15.065Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在看thinkphp5.0的远程执行代码漏洞，由于里面的类和方法实在是有点多，看别人的博客感觉不够，便想着自己把代码clone下来调试一下。由于以前调试的php基本都是单个的php脚本，<code>var_dump</code>和<code>echo</code>就能解决大多数问题，所以一直没试过单步调试php。这次我决定配置vscode使其可以调试大型的php项目。</p><h2 id="php集成开发环境"><a href="#php集成开发环境" class="headerlink" title="php集成开发环境"></a>php集成开发环境</h2><p>首先是php的集成开发环境，我以前用的是<strong>phpStudy</strong>，挺方便，但是因为phpStudy对surface的分辨率适配没做好，每次打开窗口字体都特别小，调到正常大小以后又特别模糊。所以最近换成了<strong>wampserver</strong>。安装好wampserver，打开启动apache服务。</p><h2 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h2><p>vscode需要安装两个插件，PHP Debug和PHP Intelephense。前者用来调试程序，后者提供一些语法补全和代码高亮等功能。</p><img src="/2020/02/25/Xdebug-php/plugin.png" class=""><a id="more"></a><h2 id="Xdebug"><a href="#Xdebug" class="headerlink" title="Xdebug"></a>Xdebug</h2><p>Xdebug是一个php的调试器，在用vscode调试php代码的时候，我们需要用vscode监听Xdebug的某一端口以调试。所以我们需要再安装与配置Xdebug。有一个很方便的方法就是Xdebug官方给出了一个<a href="https://xdebug.org/wizard" target="_blank" rel="noopener">Installation Wizard</a>页面方便用户进行安装。启动wampserver，打开phpinfo页面，把源代码粘贴到输入框中，页面就会生成当前版本匹配的Xdebug的dll版本，以及一个安装配置教程。</p><p>下载下来dll，打开php.ini。新版本的wampserver是集成了Xdebug的，因此在最后我们可以看到[XDebug]的字样，就是Xdebug的配置参数区域，默认也是有一个版本的dll的，但是和官网提供的版本不一样，所以我还是重新配置了一次，这里贴出来我的配置文件。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[xdebug]</span></span><br><span class="line"><span class="attr">zend_extension</span>=<span class="string">"C:\wamp64\bin\php\php7.3.12\ext\php_xdebug-2.9.2-7.3-vc15-x86_64.dll"</span></span><br><span class="line"><span class="attr">xdebug.remote_enable</span> = <span class="literal">on</span></span><br><span class="line"><span class="attr">xdebug.remote_port</span>= <span class="number">9100</span></span><br><span class="line"><span class="attr">xdebug.remote_autostart</span> = <span class="literal">on</span></span><br><span class="line"><span class="attr">xdebug.profiler_enable</span> = <span class="literal">off</span></span><br><span class="line"><span class="attr">xdebug.profiler_enable_trigger</span> = <span class="literal">Off</span></span><br><span class="line"><span class="attr">xdebug.profiler_output_name</span> = cachegrind.out.%t.%p</span><br><span class="line"><span class="attr">xdebug.profiler_output_dir</span> =<span class="string">"C:/wamp64/tmp"</span></span><br><span class="line"><span class="attr">xdebug.show_local_vars</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里有两个需要注意的地方：</p><ul><li><p>wampserver的php.ini有两个，分别存在不同的路径中，一个是存放在apache文件夹里面的，应该是php统一的设置。另外php文件夹里面每个不同的php版本里都有一个php.ini，这里要修改的配置文件应该是apache里面的那个。</p></li><li><p>前两行是开放远程监听端口，第二行是开放的端口号，如果不填默认是9000端口，这里我特意设置成了9000，因为这里实在是有点坑。最开始的时候，我用的是默认的9000端口，调试php项目的时候每次开始调试30秒左右的时候浏览器就会显示500 error，上网找了很多方法都没有用。开始以为是超时设置得太短了，打开看配置发现是300秒，可是我调试的时候半分钟就报错了。</p><p>这里我搜了很久，终于在以”xdebug    调试时间长 500错误“为关键词之后找到了原因。有网友说，php-fpm使用的端口也是9000端口，也就是说apache把php脚本送到php-fpm是通过9000进行通信的。这样Xdebug就和php-fpm冲突了。</p></li></ul><p>写好配置文件，就需要将官网提供的动态链接库文件移动到配置文件第一行对应的路径中。接着打开vscode，file-preferences-settings，打开php的settings.json，添加一行：</p><p><code>&quot;php.validate.executablePath&quot;: &quot;C:\\...\\php.exe&quot;</code></p><p>填好php.exe的路径，设置好工作区文件夹，vscode自动会在目录下面生成.vscode文件夹，里面有launch.json，打开，将一下代码配置拷贝进去。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Listen for XDebug"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"php"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">9100</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Launch currently open script"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"php"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"$&#123;fileDirname&#125;"</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">9100</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>port处填自己设置好的Xdebug端口号。然后就可以开始用vscode调试php了！</p><img src="/2020/02/25/Xdebug-php/vscode.png" class=""><p>这里安利一下一直在用的这款vscode主题: Github Plus，个人挺喜欢的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天在看thinkphp5.0的远程执行代码漏洞，由于里面的类和方法实在是有点多，看别人的博客感觉不够，便想着自己把代码clone下来调试一下。由于以前调试的php基本都是单个的php脚本，&lt;code&gt;var_dump&lt;/code&gt;和&lt;code&gt;echo&lt;/code&gt;就能解决大多数问题，所以一直没试过单步调试php。这次我决定配置vscode使其可以调试大型的php项目。&lt;/p&gt;
&lt;h2 id=&quot;php集成开发环境&quot;&gt;&lt;a href=&quot;#php集成开发环境&quot; class=&quot;headerlink&quot; title=&quot;php集成开发环境&quot;&gt;&lt;/a&gt;php集成开发环境&lt;/h2&gt;&lt;p&gt;首先是php的集成开发环境，我以前用的是&lt;strong&gt;phpStudy&lt;/strong&gt;，挺方便，但是因为phpStudy对surface的分辨率适配没做好，每次打开窗口字体都特别小，调到正常大小以后又特别模糊。所以最近换成了&lt;strong&gt;wampserver&lt;/strong&gt;。安装好wampserver，打开启动apache服务。&lt;/p&gt;
&lt;h2 id=&quot;VSCode&quot;&gt;&lt;a href=&quot;#VSCode&quot; class=&quot;headerlink&quot; title=&quot;VSCode&quot;&gt;&lt;/a&gt;VSCode&lt;/h2&gt;&lt;p&gt;vscode需要安装两个插件，PHP Debug和PHP Intelephense。前者用来调试程序，后者提供一些语法补全和代码高亮等功能。&lt;/p&gt;
&lt;img src=&quot;/2020/02/25/Xdebug-php/plugin.png&quot; class=&quot;&quot;&gt;
    
    </summary>
    
    
      <category term="vscode" scheme="https://guestblog.xyz/categories/vscode/"/>
    
      <category term="php" scheme="https://guestblog.xyz/categories/vscode/php/"/>
    
    
      <category term="vscode" scheme="https://guestblog.xyz/tags/vscode/"/>
    
      <category term="php" scheme="https://guestblog.xyz/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>wsl2闪退及出现“参考的对象类型不支持尝试的操作”的解决方法</title>
    <link href="https://guestblog.xyz/2020/02/21/wsl2problem/"/>
    <id>https://guestblog.xyz/2020/02/21/wsl2problem/</id>
    <published>2020-02-21T14:15:58.000Z</published>
    <updated>2020-02-25T07:30:20.797Z</updated>
    
    <content type="html"><![CDATA[<p>因为用的是windows insider preview，更新系统比较频繁，最近更新完系统的时候有时候打开wsl2会闪退，在终端打开会报“参考的对象类型不支持尝试的操作”的错误。后来上网找解决办法，成功解决了问题：</p><p>在管理员模式的终端下输入命令<code>netsh winsock reset</code></p><p>我觉得很神奇，上网查了很多资料包括wsl2的issue，但是还是没完全弄明白是为什么。netsh是<strong>Network Shell</strong>的简称，是一个windows系统本身提供的网络配置命令行工具。winsock是windows下的网络编程接口，这个命令的含义就是重置winsock。</p><p>github上有人说是shadowsocks和wsl2的冲突，但是我有一点还是没想明白，为什么网络接口的冲突会导致无法启动？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为用的是windows insider preview，更新系统比较频繁，最近更新完系统的时候有时候打开wsl2会闪退，在终端打开会报“参考的对象类型不支持尝试的操作”的错误。后来上网找解决办法，成功解决了问题：&lt;/p&gt;
&lt;p&gt;在管理员模式的终端下输入命令&lt;code&gt;ne
      
    
    </summary>
    
    
    
      <category term="wsl2" scheme="https://guestblog.xyz/tags/wsl2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构随笔2📝</title>
    <link href="https://guestblog.xyz/2019/12/20/DataStructure2/"/>
    <id>https://guestblog.xyz/2019/12/20/DataStructure2/</id>
    <published>2019-12-20T11:50:19.000Z</published>
    <updated>2020-02-25T14:22:55.948Z</updated>
    
    <content type="html"><![CDATA[<p>内容来源凯哥的数据结构课以及ppt。</p><a id="more"></a><h1 id="数据结构导论"><a href="#数据结构导论" class="headerlink" title="数据结构导论"></a>数据结构导论</h1><h2 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a>数据结构的定义</h2><ul><li>数据：数据就是数值，也就是我们通过观察、实验或计算得出的结果。数据有很多种，最简单的就是数字。数据也可以是文字、图像、声音等。数据可以用于科学研究、设计、查证等。</li><li>数据结构：数据结构是<strong>计算机存储、组织数据的方式</strong>。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</li><li>数据结构 = 数据 + <strong>关系</strong></li></ul><h2 id="线性结构与非线性结构"><a href="#线性结构与非线性结构" class="headerlink" title="线性结构与非线性结构"></a>线性结构与非线性结构</h2><ul><li>线性结构：线性表、队列、栈、串、数组等。</li><li>非线性结构：树、表、图，以及混合结构。</li><li>线性结构对应：结构更简单，功能更基础，维护更简单。</li><li>非线性结构对应：结构更复杂，功能更强到，维护更困难。</li></ul><h2 id="List-线性表"><a href="#List-线性表" class="headerlink" title="List 线性表"></a>List 线性表</h2><h3 id="结构特点"><a href="#结构特点" class="headerlink" title="结构特点"></a>结构特点</h3><ul><li><p><strong>全序关系</strong>，每一个元素都具有唯一的前驱和后继</p></li><li><p><strong>严格同构</strong>，任何两个组成部分之间具有相同结构</p></li></ul><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><h4 id="连续映射"><a href="#连续映射" class="headerlink" title="连续映射"></a>连续映射</h4><ul><li><p>连续映射：所有元素依据此许映射为连续而完整的物s理空间，称为<strong>顺序表</strong>。</p></li><li><p>优势：借助物理空间的连续性确保全序关系，管理简单，访问速度快。</p></li><li><p>劣势：连续空间难以预先准确规划，造成浪费或者无法扩展。</p></li><li><p>一个好的习惯：初始化.</p><p>动态创建字符数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *myBuffer=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x1f</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="离散映射"><a href="#离散映射" class="headerlink" title="离散映射"></a>离散映射</h4><ul><li><p>离散映射：各个元素映射到离散的物理空间并通过结构信息维护全序关系，称为<strong>链表</strong>。</p></li><li><p>优势：不依赖物理空间的连续性，分散存储，充分利用存储空间，具有良好可扩展性。</p></li><li><p>劣势：需要额外信息维护结构，逻辑较为复杂，动态分配内存造成额外时间消耗。</p></li></ul><h3 id="线性表："><a href="#线性表：" class="headerlink" title="线性表："></a>线性表：</h3><h4 id="实现在线性表中插入元素："><a href="#实现在线性表中插入元素：" class="headerlink" title="实现在线性表中插入元素："></a>实现在线性表中插入元素：</h4><ul><li><p>通常的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bool <span class="title">insert</span><span class="params">(struct Student value , <span class="keyword">int</span> index)</span> <span class="comment">//index从1开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (index&gt; g_studentListMgr-&gt;count+<span class="number">1</span> || g_studentListMgr-&gt;count == MAX_List_length) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">for</span>(pos = g_studentListMgr-&gt;count<span class="number">-1</span>;pos&gt;=index<span class="number">-1</span>;pos--) </span><br><span class="line">    &#123;</span><br><span class="line">        g_studentListMgr.students[pos+<span class="number">1</span>] = g_studentListMgr.students[pos]; </span><br><span class="line">    &#125;</span><br><span class="line">    g_studentListMgr.students[index<span class="number">-1</span>] = value;</span><br><span class="line">    g_studentListMgr-&gt;count+=<span class="number">1</span>；</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Insert的实现分析：</p><ul><li>最好情况：插入的位置在线性表尾部，时间复杂度为O(1)</li><li>最差情况：插入的位置在线性表头部，时间复杂度为O(n)</li><li>平均情况：各个位置都是等概率插入，时间复杂度为O(n/2)</li></ul></li><li><p>一种高效的在线性表中插入元素的方法：memmove函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">( <span class="keyword">void</span>* dest, <span class="keyword">const</span> <span class="keyword">void</span>* src, size_tcount )</span></span>;</span><br></pre></td></tr></table></figure><p>由src所指内存区域复制count个字节到dest所指内存区域。</p><p>src和dest所指内存区域可以重叠，但复制后dest内容会被更改。函数返回指向dest的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memmove(g_studentListMgr.students+index , g_studentListMgr.students+index<span class="number">-1</span> , g_studentListMgr-&gt;count - index);</span><br><span class="line">g_studentListMgr.students[index<span class="number">-1</span>] = value;</span><br></pre></td></tr></table></figure></li></ul><h4 id="remove的实现方法同理："><a href="#remove的实现方法同理：" class="headerlink" title="remove的实现方法同理："></a>remove的实现方法同理：</h4><ul><li><p>使用memmove函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memmove(g_studentListMgr.students+index<span class="number">-1</span> , g_studentListMgr.students+index , g_studentListMgr-&gt;count - index);</span><br><span class="line">g_studentListMgr.students[count] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="线性表总结："><a href="#线性表总结：" class="headerlink" title="线性表总结："></a>线性表总结：</h4><ul><li>存储空间静态分配，难以动态扩充</li><li>数据插入需要进行数据移动，代价O(n)较高</li><li>数据删除需要进行数据移动，代价O(n)较高</li><li>数据查找需要进行全表遍历，代价O(n)较高</li><li>按位置（下标）可直接获取，代价O(1)极低</li></ul><h4 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h4><ul><li><p>一个好的习惯：初始化，</p><p>创建链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UniDirectStudentList</span> <span class="title">g_studentListMgr</span>;</span></span><br><span class="line"><span class="function">Boolean <span class="title">Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_studentListMgr.head = <span class="literal">NULL</span>;</span><br><span class="line">    g_studentListMgr.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入和删除部分比较简单，不再赘述。</p></li><li><p>get和locate也比较简单，同样不再赘述。</p></li><li><p>链表的合并：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">union</span><span class="params">(struct UniDirectStudentList* list1,struct UniDirectStudentList* list2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">tmpPtr</span> , *<span class="title">tmpNode1</span>, *<span class="title">tmpNode2</span> = <span class="title">list2</span>-&gt;<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(tmpNode2!=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        tmpNode1 = list1-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(tmpNode1!=<span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(tmpNode1-&gt;id , tmpNode2-&gt;id)) </span><br><span class="line">            &#123;</span><br><span class="line">                tmpPtr = tmpNode2;</span><br><span class="line">                tmpNode2 = tmpNode2-&gt;nextAddr;</span><br><span class="line">                <span class="built_in">free</span>(tmpPtr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; tmpNode1 = tmpNode1-&gt;nextAddr; &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(tmpNode1 == <span class="literal">NULL</span>) <span class="comment">//若链表一中没有该元素，则将该元素添加到链表一头部。</span></span><br><span class="line">        &#123; </span><br><span class="line">             tmpPtr = tmpNode2; </span><br><span class="line">             tmpNode2 = tmpNode2-&gt;nextAddr;</span><br><span class="line">             tmpPtr-&gt;nextAddr = list1-&gt;head;</span><br><span class="line">             list1-&gt;head = tmpPtr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环链表的应用：CPU进程调度。</p></li></ul><h2 id="Stack栈"><a href="#Stack栈" class="headerlink" title="Stack栈"></a>Stack栈</h2><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><p><strong>栈（stack）</strong>在计算机科学中是限定仅在表尾进行插入或删除操作的<strong>线性表</strong>。栈是一种数据结构，它按照后进<strong>先出（LIFO）</strong>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。栈就是一种类似桶堆积物品的数据结构，进行删除和插入的一端称栈顶，另一端称栈底。插入一般称为<strong>压栈（push）</strong>，删除则称为<strong>弹栈（pop）</strong>。 栈也称为后进先出表。</p><h3 id="特殊之处"><a href="#特殊之处" class="headerlink" title="特殊之处"></a>特殊之处</h3><p>栈的特殊之处体现在元素的添加（push）和删除（pop）</p><h3 id="栈的层次化架构"><a href="#栈的层次化架构" class="headerlink" title="栈的层次化架构"></a>栈的层次化架构</h3><p>通用线性结构：insert, get, remove</p><p>栈结构：push, pop</p><h3 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqStudentListByArray</span>* <span class="title">g_studentListMgr</span>;</span> <span class="comment">//假设顺序表已经完成初始化</span></span><br><span class="line"><span class="function">Boolean <span class="title">push</span><span class="params">(struct Student value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> insert(value , g_studentListMgr-&gt;count+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Boolean <span class="title">pop</span><span class="params">(struct Student&amp; value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">get</span>(g_studentListMgr-&gt;count , value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">remove</span>(g_studentListMgr-&gt;count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>由于期末考试的缘故，很多知识比如后面的树和图论在梳理的同时没办法认真的把笔记整理出来了，实在是有点遗憾。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容来源凯哥的数据结构课以及ppt。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://guestblog.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://guestblog.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-next主题V7.5的配置文件修改(调整成V5.0的内容框宽度)🎈</title>
    <link href="https://guestblog.xyz/2019/12/08/modify-blog/"/>
    <id>https://guestblog.xyz/2019/12/08/modify-blog/</id>
    <published>2019-12-07T18:44:03.000Z</published>
    <updated>2020-02-25T08:34:09.430Z</updated>
    
    <content type="html"><![CDATA[<p>由于之前安装的next版本是最新的7.5，很多地方比起5.0发生了蛮大的变化，主要是字体变大以及文章内容框变宽导致看得很不习惯，于是自己开始谷歌并修改配置文件。</p><a id="more"></a><p>修改的配置文件存放在<code>MyBlog\themes\next\source\css\_schemes\Pisces\_layout.styl</code>中，选择对应的主题文件，我的是<strong>Pisces</strong>。按照网上的文档，原以为只要在结尾处加上如下代码就行了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.header&#123; <span class="attribute">width</span>: <span class="number">80%</span>; &#125; <span class="comment">/* 80% /</span></span><br><span class="line"><span class="comment">.main-inner &#123; width: 80%; &#125; / 80% */</span></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123; <span class="attribute">width</span>: calc(<span class="number">100%</span> - <span class="number">260px</span>); &#125;</span><br></pre></td></tr></table></figure><p>结果发现实际上文章的区域还是没有改变，仍旧在原来的位置，只好在其本身的width处改成<code>width: 80%;</code></p><p>成功解决。</p><p>字体则是把所有字号都缩小，代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Font size</span></span><br><span class="line">$font-size-base           = (hexo-config('font.enable') and hexo-config('font.global.size') is a 'unit') ? unit(hexo-config('font.global.size'), em) : 1em;</span><br><span class="line">$font-size-smallest       = .675em;</span><br><span class="line">$font-size-smaller        = .75em;</span><br><span class="line">$font-size-small          = .8125em;</span><br><span class="line">$font-size-medium         = .875em;</span><br><span class="line">$font-size-large          = 1em;</span><br><span class="line">$font-size-larger         = 1.125em;</span><br><span class="line">$font-size-largest        = 1.25em;</span><br></pre></td></tr></table></figure><p>整个博客看起来舒服多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于之前安装的next版本是最新的7.5，很多地方比起5.0发生了蛮大的变化，主要是字体变大以及文章内容框变宽导致看得很不习惯，于是自己开始谷歌并修改配置文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://guestblog.xyz/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://guestblog.xyz/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构随笔💡</title>
    <link href="https://guestblog.xyz/2019/12/06/DataStructure1/"/>
    <id>https://guestblog.xyz/2019/12/06/DataStructure1/</id>
    <published>2019-12-06T01:24:57.000Z</published>
    <updated>2020-02-25T06:49:57.629Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构课也算是一学期快要上完了，尽管凯哥吹了一学期的牛，似乎并没有讲什么数据结构方面具体的知识，但我感觉一学期下来收获良多。可能是因为凯哥讲课比较注重方法论，许多具体的点，尽管不细讲，但他会跟我们讲明白原理，讲一些计算机的底层的架构，我觉得这些对我思想方面的提升是巨大的。我觉得数据结构这门课在凯哥的引导以及自学下慢慢领悟到了一些思想了。有的时候看凯哥其实更像一个计组老师，我很感激他。</p><a id="more"></a><p>最近在写一个图论的作业，写着写着突然想起来以前和学长的聊天：<br>还没上大学的时候，根本就不知道数据结构的含义，只知道大学要开这门课，学长对我说以后数据结构一定要好好学，基础打扎实。我那时候还不明白为什么，我问他你们数据结构学了什么呢？他说堆栈、树、图之类的，我说那这不是算法吗？他说还是有一定的区别的。</p><p>我觉得把数据结构和算法等同是我以前一个十分幼稚的想法，初中的时候打过oi，那时候学了一大堆算法，分治、贪心、动态规划以及一大堆现在已经叫不上名的算法。但实际上感觉当时自己只是机械地去为了做题学了一堆算法，根本没有对这一门学问进行一个思想方面的总结。</p><p>现在回头来看，感觉数据结构和算法最大的区别，就是<strong>两者注重的方面不一样</strong>。数据结构和算法都是程序员在解决问题中需要用到的技能，不同的数据结构配合着不同的算法。</p><p>数据结构，我觉得最重要的是学会面对一个具体的问题时提出一个<strong>合适</strong>的模型来存储数据。我认为一个模型并不一定要符合问题本身的特征，例如一排小朋友排队，并不一定就要建立一个线性表，用树也是可以的，具体却决于问题。数据结构的建立应当基于自己所需要解决的问题，使得在这一数据结构下算法有着最高效发挥的余地。比如我这几天的作业就是要写图的Dijkstra算法，我一开始想偷懒用二维邻接矩阵来存储边的长度，但如果使用这样的数据结构，每从一个节点出发的时候都得进行O(n)的遍历来判断边是否走得通。因此我选择用邻接链表来存储边，这样在建立数据结构的时候会稍显麻烦，因为每一次都得找到节点的存储边的链表的最后一位。但这样在遍历的时候每一次只需要遍历节点对应的邻接链表就可以了，大大减少了时间开销。</p><p>而算法，我觉得是提升效率的一个拓展，但如果没有合适的数据结构，算法也很难有发挥的余地。算法的内容博大精深，但是很多时候的情况并不需要用到一些特别复杂的算法，一些经典的算法已经可以解决绝大多数的问题。而再往后的算法都是一些具体的优化与博弈，是要根据具体问题设计的。总的来说我觉得没有完美的算法，大多数不同的算法的设计其实是在牺牲不必要的变量换取所需的变量，例如时间和空间，根据具体问题选择倾向的对象。但也有些算法，它牺牲的变量对于换取的价值来说几乎不值一提，例如<strong>快速排序</strong>，因此会显得比原先的算法高效得多。</p><p>掌握算法固然重要，但若是想我以前一样罔顾数据结构盲目学算法的话，终究没法领悟算法的精髓，有的时候设计出一个漂亮的数据结构也能带来等同于设计出一个漂亮算法的喜悦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构课也算是一学期快要上完了，尽管凯哥吹了一学期的牛，似乎并没有讲什么数据结构方面具体的知识，但我感觉一学期下来收获良多。可能是因为凯哥讲课比较注重方法论，许多具体的点，尽管不细讲，但他会跟我们讲明白原理，讲一些计算机的底层的架构，我觉得这些对我思想方面的提升是巨大的。我觉得数据结构这门课在凯哥的引导以及自学下慢慢领悟到了一些思想了。有的时候看凯哥其实更像一个计组老师，我很感激他。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://guestblog.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://guestblog.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>搭建hexo博客、配置next主题踩的无数坑🤦‍♂️</title>
    <link href="https://guestblog.xyz/2019/11/09/build-blog/"/>
    <id>https://guestblog.xyz/2019/11/09/build-blog/</id>
    <published>2019-11-09T04:05:17.000Z</published>
    <updated>2020-02-24T15:56:51.207Z</updated>
    
    <content type="html"><![CDATA[<p>昨天折腾一晚上总算是把hexo的博客搭出来了，由于同之前的hugo差异很大，在这过程中踩了无数坑。</p><p>首先是next的版本，原先在next作者issnan的网站上下载的next是5.1.4版本的，结果运行的过程中控制台一直发提醒，才发现next官方的github上已经是7.0.0版本了，因此又重新下载了一次。</p><p>接着是本地调试，本地调试很顺利，几乎没有遇到什么坑。</p><p>为了修改自己的配置，打开_config.yml开始改参数。</p><h5 id="顺着文档一条一条来，不懂的看别人博客、看注释。"><a href="#顺着文档一条一条来，不懂的看别人博客、看注释。" class="headerlink" title="顺着文档一条一条来，不懂的看别人博客、看注释。"></a>顺着文档一条一条来，不懂的看别人博客、看注释。</h5><a id="more"></a><ol><li><p>先改网站的图标，这里有个bug很奇怪，我用自己的ico的时候网站加载不出来，用默认的png却可以，于是上网把ico转换成了png，接着就成功了。</p></li><li><p>然后是菜单，菜单这里next的5.1.4版本又有个bug，路径和emoji之间用||分开，但是||前若是加空格就无法识别路径，这个bug在7.0.0里面没有了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br></pre></td></tr></table></figure></li><li><p>social一栏，本来想把邮箱放进去的，但是mailto语句又无法起作用，这个问题现在也没解决，只好注释掉了邮箱这一栏。</p></li><li><p>github_banner这一个模块很有意思，会在页面右上角生成一个猫头，挺可爱的。</p></li><li><p>最后是动态背景，搞了很久都没成功，enable: true不起作用，最后谷歌才发现在7.0.0版本中各种动画效果都是需要先安装依赖才能使用的，顺着注释找到依赖以后很快就解决了问题。</p></li></ol><h5 id="全部搞好以后就准备push到github上面了，这个环节是我折腾的最久的部分。"><a href="#全部搞好以后就准备push到github上面了，这个环节是我折腾的最久的部分。" class="headerlink" title="全部搞好以后就准备push到github上面了，这个环节是我折腾的最久的部分。"></a>全部搞好以后就准备push到github上面了，这个环节是我折腾的最久的部分。</h5><p>首先我在github上创建了一个新的repo，命名为xxx.github.io，接着</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git config --global user.name gitaccount</span><br><span class="line">git config --global user.email gitaccount@example.com</span><br><span class="line">git remote add origin master https:&#x2F;&#x2F;xxx</span><br><span class="line">git push orgin master</span><br></pre></td></tr></table></figure><p>结果遇到了一个问题 update were rejected because the tip of your current branch is behind .... </p><p>谷歌以后，原来是因为github上面有README.md而本地仓库没有，所以先pull下来，再push，解决问题。</p><p>终于push上去了，但是repo的settings页面又显示AUTHOR.md解析错误。随后谷歌无果，我把这个md删除了（不是特别重要），结果就成功了。</p><h5 id="本来以为没事了，打开博客发现404。最后咨询了神仙学弟终于获得了解决方案。"><a href="#本来以为没事了，打开博客发现404。最后咨询了神仙学弟终于获得了解决方案。" class="headerlink" title="本来以为没事了，打开博客发现404。最后咨询了神仙学弟终于获得了解决方案。"></a>本来以为没事了，打开博客发现404。最后咨询了神仙学弟终于获得了解决方案。</h5><p>原先一直想着自己push就没有想用hexo官方给出的办法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>最后才发现这方法比push效率高多了。</p><p><strong>原来自己对hexo生成博客的认识有一个很大的误区</strong>，以为把本地文件push到github就可以自动生成了。实际上本地的文件只是方便自己配置而设置的，实际上配置好以后还需要用generate生成静态网站，再把generate指令生成的文件push到github上才能出现页面。现在想想原来的文件夹里面连index.html都没有🤣。</p><p>这一次搭建博客，最深刻的感受就是自己对git的使用和静态网站生成的原理还不够熟悉，踩了无数坑，谷歌了无数次，但也收获良多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天折腾一晚上总算是把hexo的博客搭出来了，由于同之前的hugo差异很大，在这过程中踩了无数坑。&lt;/p&gt;
&lt;p&gt;首先是next的版本，原先在next作者issnan的网站上下载的next是5.1.4版本的，结果运行的过程中控制台一直发提醒，才发现next官方的github上已经是7.0.0版本了，因此又重新下载了一次。&lt;/p&gt;
&lt;p&gt;接着是本地调试，本地调试很顺利，几乎没有遇到什么坑。&lt;/p&gt;
&lt;p&gt;为了修改自己的配置，打开_config.yml开始改参数。&lt;/p&gt;
&lt;h5 id=&quot;顺着文档一条一条来，不懂的看别人博客、看注释。&quot;&gt;&lt;a href=&quot;#顺着文档一条一条来，不懂的看别人博客、看注释。&quot; class=&quot;headerlink&quot; title=&quot;顺着文档一条一条来，不懂的看别人博客、看注释。&quot;&gt;&lt;/a&gt;顺着文档一条一条来，不懂的看别人博客、看注释。&lt;/h5&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://guestblog.xyz/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://guestblog.xyz/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="github" scheme="https://guestblog.xyz/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Welcome to my blog! 😜</title>
    <link href="https://guestblog.xyz/2019/11/07/welcome/"/>
    <id>https://guestblog.xyz/2019/11/07/welcome/</id>
    <published>2019-11-07T13:41:10.000Z</published>
    <updated>2019-11-08T12:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到我的博客 : )</p><p>原来的博客由于github账号修改username而挂了，原先的博客是用的hugo生成的。本来想迁移过来的，后来发现hexo上的next主题很是讨喜，于是又重新搭了这个博客。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到我的博客 : )&lt;/p&gt;
&lt;p&gt;原来的博客由于github账号修改username而挂了，原先的博客是用的hugo生成的。本来想迁移过来的，后来发现hexo上的next主题很是讨喜，于是又重新搭了这个博客。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随笔" scheme="https://guestblog.xyz/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="life" scheme="https://guestblog.xyz/tags/life/"/>
    
  </entry>
  
</feed>
